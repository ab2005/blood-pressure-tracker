<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–¢—Ä–µ–∫–µ—Ä –∞—Ä—Ç–µ—Ä–∏–∞–ª—å–Ω–æ–≥–æ –¥–∞–≤–ª–µ–Ω–∏—è</title>

    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="BP Tracker">
    <meta name="description" content="–û—Ç—Å–ª–µ–∂–∏–≤–∞–π—Ç–µ —Å–≤–æ–µ –∞—Ä—Ç–µ—Ä–∏–∞–ª—å–Ω–æ–µ –¥–∞–≤–ª–µ–Ω–∏–µ –µ–∂–µ–¥–Ω–µ–≤–Ω–æ">

    <!-- PWA Manifest -->
    <link rel="manifest" href="data:application/manifest+json;base64,ewogICJuYW1lIjogItCi0YDQtdC60LXRgCDQsNGA0YLQtdGA0LjQsNC70YzQvdC+0LPQviDQtNCw0LLQu9C10L3QuNGPIiwKICAic2hvcnRfbmFtZSI6ICJCUCBUcmFja2VyIiwKICAiZGVzY3JpcHRpb24iOiAi0J7RgtGB0LvQtdC20LjQstCw0LnRgtC1INGB0LLQvtGRINCw0YDRgtC10YDQuNCw0LvRjNC90L7QtSDQtNCw0LLQu9C10L3QuNC1INC10LbQtdC00L3QtdCy0L3QviIsCiAgInN0YXJ0X3VybCI6ICIvIiwKICAiZGlzcGxheSI6ICJzdGFuZGFsb25lIiwKICAiYmFja2dyb3VuZF9jb2xvciI6ICIjNjY3ZWVhIiwKICAidGhlbWVfY29sb3IiOiAiIzY2N2VlYSIsCiAgIm9yaWVudGF0aW9uIjogInBvcnRyYWl0IiwKICAiaWNvbnMiOiBbCiAgICB7CiAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpVMklpQm9aV2xuYUhROUlqSTFOaUlnZG1sbGQwSnZlRDBpTUNBd0lESTFOaUF5TlRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQR1JsWm5NK1BHeHBibVZoY2tkeVlXUnBaVzUwSUdsa1BTSm5jbUZrSWlCNE1UMGlNQ1VpSUhreFBTSXdKU0lnZURJOUlqRXdNQ1VpSUhreFBTSXhNREFsSWo0OGMzUnZjQ0J2Wm1aelpYUTlJakFsSWlCemRIbHNaVDBpYzNSdmNDMWpiMnh2Y2pvMk5qZGxaV0U3YzNSdmNDMXZjR0ZqYVhSNU9qRWlJQzgrUEhOMGIzQWdiMlptYzJWMFBTSXhNREFsSWlCemRIbHNaVDBpYzNSdmNDMWpiMnh2Y2pvM05qUmlZVEk3YzNSdmNDMXZjR0ZqYVhSNU9qRWlJQzgrUEM5c2FXNWxZWEpIY21Ga2FXVnVkRDQ4TDJSbFpuTStQR05wY21Oc1pTQmplRDBpTVRJNElpQmplVDBpTVRJNElpQnlQU0l4TWpnaUlHWnBiR3c5SW5WeWJDZ2paMkpoWkNraUx6NDhkR1Y0ZENCNFBTSTJORE1pSUhrOUlqRTFOaUlnZEdWNGRDMWhibU5vYjNJOUltMXBaR1JzWlNJZ1ptbHNiRDBpZDJocGRHVWlJR1p2Ym5RdFptRnRhV3g1UFNKQmNtbGhiQ3dnYzJGdWN5MXpaWEpwWmlJZ1ptOXVkQzF6YVhwbFBTSTBPQ0lnWm05dWRDMTNaV2xuYUhROUltSnZiR1FpUGpnNFBDOTBaWGgwUGp3dmMzWm5QZz09IiwKICAgICAgInNpemVzIjogIjI1NngyNTYiLAogICAgICAidHlwZSI6ICJpbWFnZS9zdmcreG1sIiwKICAgICAgInB1cnBvc2UiOiAiYW55IG1hc2thYmxlIgogICAgfQogIF0sCiAgImNhdGVnb3JpZXMiOiBbImhlYWx0aCIsICJtZWRpY2FsIiwgImxpZmVzdHlsZSJdCn0=">

    <!-- Apple Touch Icons -->
    <link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgdmlld0JveD0iMCAwIDI1NiAyNTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJncmFkIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIxMDAlIj48c3RvcCBvZmZzZXQ9IjAlIiBzdHlsZT0ic3RvcC1jb2xvcjo2NjdlZWE7c3RvcC1vcGFjaXR5OjEiIC8+PHN0b3Agb2Zmc2V0PSIxMDAlIiBzdHlsZT0ic3RvcC1jb2xvcjo3NjRiYTI7c3RvcC1vcGFjaXR5OjEiIC8+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PGNpcmNsZSBjeD0iMTI4IiBjeT0iMTI4IiByPSIxMjgiIGZpbGw9InVybCgjZ3JhZCkiLz48dGV4dCB4PSI2NCIgeT0iMTU2IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSJ3aGl0ZSIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjQ4IiBmb250LXdlaWdodD0iYm9sZCI+ODg8L3RleHQ+PC9zdmc+">

    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            line-height: 1.6;
        }

        .app-container {
            max-width: 100%;
            min-height: 100vh;
            position: relative;
        }

        /* Mobile-first responsive breakpoints */
        @media (min-width: 768px) {
            .app-container {
                max-width: 768px;
                margin: 0 auto;
                padding: 20px;
            }
        }

        @media (min-width: 1024px) {
            .app-container {
                max-width: 900px;
            }
        }

        .container {
            background: white;
            border-radius: 0;
            padding: 16px;
            box-shadow: none;
            min-height: 100vh;
        }

        @media (min-width: 768px) {
            .container {
                border-radius: 20px;
                padding: 32px;
                margin: 20px;
                min-height: calc(100vh - 40px);
                box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            }
        }

        .pwa-install-banner {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }

        .pwa-install-banner button {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            margin: 0 5px;
            cursor: pointer;
        }

        .pwa-install-banner button:hover {
            background: rgba(255,255,255,0.3);
        }

        .offline-indicator {
            background: #ef4444;
            color: white;
            padding: 10px;
            text-align: center;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .online-indicator {
            background: #10b981;
            color: white;
            padding: 10px;
            text-align: center;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }


        h1 {
            color: #4a5568;
            text-align: center;
            margin-bottom: 24px;
            font-size: 1.75rem;
            font-weight: 700;
        }

        @media (min-width: 768px) {
            
            h1 {
                font-size: 2.2rem;
                margin-bottom: 32px;
            }
        }

        .input-section {
            background: #f8fafc;
            padding: 20px;
            border-radius: 16px;
            margin-bottom: 24px;
            border: 1px solid #e2e8f0;
        }

        @media (min-width: 768px) {
            .input-section {
                padding: 24px;
                margin-bottom: 32px;
            }
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-bottom: 20px;
        }

        @media (min-width: 480px) {
            .input-group {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 16px;
            }
        }

        .symptoms-group {
            grid-column: 1 / -1;
            margin-top: 16px;
        }

        .symptoms-title {
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 12px;
            display: block;
            font-size: 14px;
        }

        .symptoms-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
        }

        @media (min-width: 480px) {
            .symptoms-grid {
                grid-template-columns: repeat(5, 1fr);
                gap: 10px;
            }
        }

        @media (min-width: 768px) {
            .symptoms-grid {
                grid-template-columns: repeat(5, 1fr);
                gap: 12px;
            }
        }

        .symptom-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            padding: 12px 8px;
            background: white;
            border-radius: 12px;
            border: 2px solid #e2e8f0;
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
            min-height: 50px;
            aspect-ratio: 1;
        }

        .symptom-item:hover {
            border-color: #667eea;
            background: #f8fafc;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.1);
        }

        .symptom-item.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .symptom-item.selected .symptom-icon {
            filter: brightness(0) invert(1);
        }

        .symptom-checkbox {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            margin: 0;
        }

        .symptom-icon {
            font-size: 24px;
            transition: all 0.2s ease;
        }

        .symptom-label {
            display: none;
        }

        @media (min-width: 480px) {
            .symptom-item {
                min-height: 60px;
                padding: 16px 12px;
            }
            
            .symptom-icon {
                font-size: 28px;
            }
        }

        @media (min-width: 768px) {
            .symptom-item {
                min-height: 70px;
                padding: 18px 14px;
            }
            
            .symptom-icon {
                font-size: 32px;
            }
        }

        label {
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 5px;
            display: block;
        }

        input, select {
            width: 100%;
            padding: 14px 16px;
            border: 1px solid #d1d5db;
            border-radius: 12px;
            font-size: 16px;
            transition: all 0.2s ease;
            box-sizing: border-box;
            background: white;
            -webkit-appearance: none;
            appearance: none;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }


        .bp-inputs {
            display: flex;
            gap: 12px;
            align-items: center;
            justify-content: center;
        }

        .bp-inputs input {
            width: 80px;
            text-align: center;
            font-weight: 600;
        }

        @media (min-width: 480px) {
            .bp-inputs input {
                width: 90px;
            }
        }

        .separator {
            font-size: 24px;
            font-weight: bold;
            color: #4a5568;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 16px 24px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .readings-section {
            margin-top: 30px;
        }

        .readings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .controls-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .controls-group button {
            width: 100%;
        }

        @media (min-width: 480px) {
            .controls-group {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 12px;
            }
            
            .controls-group button {
                width: auto;
                flex: 1;
                min-width: 120px;
            }
        }

        .notification-controls {
            background: #f1f5f9;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #e2e8f0;
        }

        .notification-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 24px;
        }

        @media (min-width: 480px) {
            .stats {
                grid-template-columns: repeat(4, 1fr);
                gap: 16px;
            }
        }

        .stat-card {
            background: #f1f5f9;
            padding: 16px 12px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.9em;
            color: #64748b;
            margin-top: 5px;
        }

        .chart-section {
            margin: 25px 0;
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
            border: 2px solid #e2e8f0;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .chart-toggle {
            background: #10b981;
            font-size: 14px;
            padding: 8px 16px;
            width: auto;
        }

        .chart-toggle:hover {
            background: #059669;
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 15px;
        }

        .chart-canvas {
            width: 100%;
            height: 100%;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: white;
        }

        .chart-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        .table-container {
            overflow-x: auto;
            margin-top: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            min-width: 600px;
        }

        th, td {
            padding: 12px 8px;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
            font-size: 14px;
        }

        @media (min-width: 768px) {
            th, td {
                padding: 12px 16px;
            }
        }

        th {
            background: #f8fafc;
            font-weight: 600;
            color: #4a5568;
        }

        tr:hover {
            background: #f8fafc;
        }

        .delete-btn {
            background: #ef4444;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            width: auto;
        }

        .delete-btn:hover {
            background: #dc2626;
            transform: none;
            box-shadow: none;
        }

        .no-data {
            text-align: center;
            color: #64748b;
            font-style: italic;
            padding: 40px;
        }

        .bp-reading {
            font-weight: bold;
        }

        .bp-normal { color: #10b981; }
        .bp-elevated { color: #f59e0b; }
        .bp-high { color: #ef4444; }

        .secondary-btn {
            background: #6b7280;
            font-size: 14px;
            padding: 8px 16px;
            width: auto;
        }

        .secondary-btn:hover {
            background: #4b5563;
        }

        .export-btn {
            background: #059669;
        }

        .export-btn:hover {
            background: #047857;
        }

        .import-btn {
            background: #7c3aed;
        }

        .import-btn:hover {
            background: #6d28d9;
        }

        .hidden {
            display: none;
        }

        .symptoms-display {
            font-size: 12px;
            color: #64748b;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .file-input {
            display: none;
        }

        .footer {
            margin-top: 40px;
            padding: 25px;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border-radius: 12px;
            border: 2px solid #e2e8f0;
            text-align: center;
        }

        .author-profile {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .profile-photo {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid #667eea;
            object-fit: cover;
        }

        .author-info {
            text-align: left;
        }

        .author-name {
            font-weight: 600;
            color: #4a5568;
            font-size: 16px;
            margin: 0;
        }

        .author-email {
            color: #64748b;
            font-size: 14px;
            margin: 2px 0 0 0;
        }

        .contact-links {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
        }

        .contact-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: #667eea;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            width: auto;
        }

        .contact-btn:hover {
            background: #5a67d8;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .copyright {
            font-size: 12px;
            color: #64748b;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e2e8f0;
        }

        /* PWA Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Improved spacing and visual hierarchy */
        .readings-section {
            margin-top: 24px;
        }

        .readings-header h2 {
            color: #4a5568;
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0;
        }

        @media (min-width: 768px) {
            .readings-header h2 {
                font-size: 1.5rem;
            }
        }

        /* Camera Functionality Styles */
        .camera-section {
            background: #f8fafc;
            border-radius: 16px;
            padding: 20px;
            margin-top: 24px;
            border: 1px solid #e2e8f0;
        }

        .camera-section h3 {
            color: #4a5568;
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0 0 12px 0;
            text-align: center;
        }

        .camera-instruction {
            text-align: center;
            color: #6b7280;
            font-size: 14px;
            margin-bottom: 20px;
        }

        .camera-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
        }

        @media (min-width: 480px) {
            .camera-controls {
                flex-direction: row;
                justify-content: center;
            }
        }

        .camera-controls button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 44px;
        }

        .camera-controls button:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .camera-controls button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .camera-container {
            margin: 20px 0;
            text-align: center;
        }

        #camera-stream {
            width: 100%;
            max-width: 400px;
            height: auto;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .captured-image {
            margin: 20px 0;
            text-align: center;
        }

        .captured-image h4 {
            color: #4a5568;
            margin-bottom: 16px;
        }

        .image-controls {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-top: 16px;
            flex-wrap: wrap;
        }

        .image-controls button {
            background: #10b981;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .image-controls button:hover {
            background: #059669;
            transform: translateY(-1px);
        }

        .image-controls button:last-child {
            background: #6b7280;
        }

        .image-controls button:last-child:hover {
            background: #4b5563;
        }

        .ocr-result {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #d1d5db;
        }

        .ocr-result h4 {
            color: #4a5568;
            margin-bottom: 16px;
        }

        #ocr-readings {
            background: #f3f4f6;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            font-family: monospace;
            color: #374151;
            white-space: pre-wrap;
        }

        .ocr-result button {
            background: #059669;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
        }

        .ocr-result button:hover {
            background: #047857;
            transform: translateY(-1px);
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .loading-content {
            background: white;
            padding: 32px;
            border-radius: 16px;
            text-align: center;
            max-width: 300px;
        }

        .loading-content .loading-spinner {
            margin: 0 auto 16px;
        }

        .api-status {
            text-align: center;
            margin: 10px 0;
            padding: 8px;
            background: #f1f5f9;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }

        .api-status small {
            color: #64748b;
            font-size: 12px;
        }

        #current-api {
            font-weight: 600;
            color: #4a5568;
        }

        /* Voice Input Styles */
        .voice-section {
            background: #f8fafc;
            border-radius: 16px;
            padding: 20px;
            margin-top: 24px;
            border: 1px solid #e2e8f0;
        }

        .voice-section h3 {
            color: #4a5568;
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0 0 12px 0;
            text-align: center;
        }

        .voice-instruction {
            text-align: center;
            color: #6b7280;
            font-size: 14px;
            margin-bottom: 20px;
        }

        .voice-controls {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .voice-controls button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 44px;
        }

        .voice-controls button:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .voice-controls button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .voice-feedback {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid #d1d5db;
            text-align: center;
        }

        .voice-visualizer {
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 16px;
        }

        .voice-wave {
            width: 100px;
            height: 40px;
            background: linear-gradient(to right, #667eea 0%, #764ba2 100%);
            border-radius: 20px;
            position: relative;
            overflow: hidden;
        }

        .voice-wave::before {
            content: '';
            position: absolute;
            top: 50%;
            left: -100%;
            width: 100%;
            height: 2px;
            background: rgba(255, 255, 255, 0.8);
            transform: translateY(-50%);
            animation: wave 1.5s linear infinite;
        }

        @keyframes wave {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        #voice-status {
            color: #4a5568;
            font-weight: 600;
            margin: 0;
        }

        .voice-result {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #d1d5db;
        }

        .voice-result h4 {
            color: #4a5568;
            margin-bottom: 16px;
        }

        #voice-transcript {
            background: #f3f4f6;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            font-family: monospace;
            color: #374151;
            white-space: pre-wrap;
        }

        #voice-readings {
            background: #e8f5e9;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            color: #2e7d32;
            font-weight: 600;
        }

        .voice-actions {
            display: flex;
            gap: 12px;
            margin-top: 16px;
        }

        .voice-actions button {
            background: #059669;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
        }

        .voice-actions button:hover {
            background: #047857;
            transform: translateY(-1px);
        }

        .ocr-actions {
            display: flex;
            gap: 12px;
            margin-top: 16px;
        }

        .ocr-actions button {
            background: #059669;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
        }

        .ocr-actions button:hover {
            background: #047857;
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loading-screen">
        <div class="loading-spinner"></div>
        <h2>–¢—Ä–µ–∫–µ—Ä –î–∞–≤–ª–µ–Ω–∏—è</h2>
        <p>–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö...</p>
    </div>

    <div class="app-container">
    <div class="container">
        <!-- PWA Install Banner -->
        <div class="pwa-install-banner" id="install-banner">
            <div>üì± –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –¥–ª—è –ª—É—á—à–µ–≥–æ –æ–ø—ã—Ç–∞!</div>
            <div style="margin-top: 10px;">
                <button onclick="installPWA()">–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>
                <button onclick="dismissInstallBanner()">–ù–µ —Å–µ–π—á–∞—Å</button>
            </div>
        </div>

        <h1>ü©∫ –¢—Ä–µ–∫–µ—Ä –∞—Ä—Ç–µ—Ä–∏–∞–ª—å–Ω–æ–≥–æ –¥–∞–≤–ª–µ–Ω–∏—è</h1>

        <!-- Connection Status -->
        <div class="offline-indicator" id="offline-indicator">
            üì° –ù–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è - —Ä–∞–±–æ—Ç–∞–µ–º –≤ –∞–≤—Ç–æ–Ω–æ–º–Ω–æ–º —Ä–µ–∂–∏–º–µ
        </div>
        <div class="online-indicator" id="online-indicator">
            ‚úÖ –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ - –¥–∞–Ω–Ω—ã–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω—ã
        </div>



        <div class="input-section">
            <div class="input-group">
                <div>
                    <label for="date">–î–∞—Ç–∞:</label>
                    <input type="date" id="date" required>
                </div>
                <div>
                    <label for="time">–í—Ä–µ–º—è:</label>
                    <input type="time" id="time" required>
                </div>
            </div>

            <div class="input-group">
                <div>
                    <label>–ê—Ä—Ç–µ—Ä–∏–∞–ª—å–Ω–æ–µ –¥–∞–≤–ª–µ–Ω–∏–µ (–º–º —Ä—Ç. —Å—Ç.):</label>
                    <div class="bp-inputs">
                        <input type="number" id="systolic" placeholder="120" min="50" max="300" required>
                        <span class="separator">/</span>
                        <input type="number" id="diastolic" placeholder="80" min="30" max="200" required>
                    </div>
                </div>
                <div>
                    <label for="pulse">–ü—É–ª—å—Å (—É–¥/–º–∏–Ω):</label>
                    <input type="number" id="pulse" placeholder="75" min="30" max="200">
                </div>
            </div>

            <div class="symptoms-group">
                <label class="symptoms-title">–°–æ–ø—É—Ç—Å—Ç–≤—É—é—â–∏–µ —Ñ–∞–∫—Ç–æ—Ä—ã –∏ —Å–∏–º–ø—Ç–æ–º—ã:</label>
                <div class="symptoms-grid">
                    <div class="symptom-item" onclick="toggleSymptom('headache')" title="–ì–æ–ª–æ–≤–Ω–∞—è –±–æ–ª—å">
                        <input type="checkbox" id="headache" class="symptom-checkbox">
                        <div class="symptom-icon">ü§ï</div>
                    </div>
                    <div class="symptom-item" onclick="toggleSymptom('tinnitus')" title="–®—É–º –≤ —É—à–∞—Ö">
                        <input type="checkbox" id="tinnitus" class="symptom-checkbox">
                        <div class="symptom-icon">üëÇ</div>
                    </div>
                    <div class="symptom-item" onclick="toggleSymptom('dizziness')" title="–ì–æ–ª–æ–≤–æ–∫—Ä—É–∂–µ–Ω–∏–µ">
                        <input type="checkbox" id="dizziness" class="symptom-checkbox">
                        <div class="symptom-icon">üòµ‚Äçüí´</div>
                    </div>
                    <div class="symptom-item" onclick="toggleSymptom('anxiety')" title="–¢—Ä–µ–≤–æ–∂–Ω–æ—Å—Ç—å">
                        <input type="checkbox" id="anxiety" class="symptom-checkbox">
                        <div class="symptom-icon">üò∞</div>
                    </div>
                    <div class="symptom-item" onclick="toggleSymptom('poor_sleep')" title="–ü–ª–æ—Ö–æ–π —Å–æ–Ω">
                        <input type="checkbox" id="poor_sleep" class="symptom-checkbox">
                        <div class="symptom-icon">üò¥</div>
                    </div>
                    <div class="symptom-item" onclick="toggleSymptom('alcohol')" title="–ê–ª–∫–æ–≥–æ–ª—å –Ω–∞–∫–∞–Ω—É–Ω–µ">
                        <input type="checkbox" id="alcohol" class="symptom-checkbox">
                        <div class="symptom-icon">üç∑</div>
                    </div>
                    <div class="symptom-item" onclick="toggleSymptom('exercise')" title="–ü–æ—Å–ª–µ –Ω–∞–≥—Ä—É–∑–∫–∏">
                        <input type="checkbox" id="exercise" class="symptom-checkbox">
                        <div class="symptom-icon">üí™</div>
                    </div>
                    <div class="symptom-item" onclick="toggleSymptom('stress')" title="–°—Ç—Ä–µ—Å—Å">
                        <input type="checkbox" id="stress" class="symptom-checkbox">
                        <div class="symptom-icon">üò§</div>
                    </div>
                    <div class="symptom-item" onclick="toggleSymptom('fatigue')" title="–£—Å—Ç–∞–ª–æ—Å—Ç—å">
                        <input type="checkbox" id="fatigue" class="symptom-checkbox">
                        <div class="symptom-icon">üòÆ‚Äçüí®</div>
                    </div>
                </div>
            </div>

            <div class="input-group">
                <div>
                    <label for="notes">–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∑–∞–º–µ—Ç–∫–∏:</label>
                    <input type="text" id="notes" placeholder="–¥—Ä—É–≥–∏–µ –≤–∞–∂–Ω—ã–µ –¥–µ—Ç–∞–ª–∏...">
                </div>
            </div>

            <button onclick="addReading()">üìä –î–æ–±–∞–≤–∏—Ç—å –∏–∑–º–µ—Ä–µ–Ω–∏–µ</button>
            
            <!-- Voice Input Section -->
            <div class="voice-section">
                <h3>üé§ –ì–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥</h3>
                <p class="voice-instruction">–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –∏ –ø—Ä–æ–∏–∑–Ω–µ—Å–∏—Ç–µ –ø–æ–∫–∞–∑–∞–Ω–∏—è, –Ω–∞–ø—Ä–∏–º–µ—Ä: "120 –Ω–∞ 80, –ø—É–ª—å—Å 75, –≥–æ–ª–æ–≤–Ω–∞—è –±–æ–ª—å, —Å—Ç—Ä–µ—Å—Å". –°–∏—Å—Ç–µ–º–∞ –∂–¥–µ—Ç 4 —Å–µ–∫—É–Ω–¥—ã –ø–æ—Å–ª–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –¥–∞–≤–ª–µ–Ω–∏—è –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –ø—É–ª—å—Å–∞ –∏ —Å–∏–º–ø—Ç–æ–º–æ–≤.</p>
                
                <div class="voice-controls">
                    <button id="voice-btn" onclick="startVoiceInput()">üé§ –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å</button>
                    <button id="stop-voice-btn" onclick="stopVoiceInput()" style="display: none;">‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–∞–ø–∏—Å—å</button>
                </div>
                
                <div class="voice-feedback" id="voice-feedback" style="display: none;">
                    <div class="voice-visualizer">
                        <div class="voice-wave"></div>
                    </div>
                    <p id="voice-status">–°–ª—É—à–∞—é...</p>
                </div>
                
                <div class="voice-result" id="voice-result" style="display: none;">
                    <h4>–†–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç:</h4>
                    <div id="voice-transcript"></div>
                    <div id="voice-readings"></div>
                    <div class="voice-actions">
                        <button onclick="useVoiceReadings()">üìù –ó–∞–ø–æ–ª–Ω–∏—Ç—å —Ñ–æ—Ä–º—É</button>
                        <button onclick="saveVoiceReadings()" style="background: #10b981;">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å—Ä–∞–∑—É</button>
                    </div>
                </div>
            </div>
            
            <!-- Camera Section -->
            <div class="camera-section">
                <h3>üì∑ –°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –ø–æ–∫–∞–∑–∞–Ω–∏—è —Ç–æ–Ω–æ–º–µ—Ç—Ä–∞</h3>
                <p class="camera-instruction">–ù–∞–≤–µ–¥–∏—Ç–µ –∫–∞–º–µ—Ä—É –Ω–∞ –¥–∏—Å–ø–ª–µ–π —Ç–æ–Ω–æ–º–µ—Ç—Ä–∞ –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Å—á–∏—Ç—ã–≤–∞–Ω–∏—è –ø–æ–∫–∞–∑–∞–Ω–∏–π</p>
                <div id="api-status" class="api-status" style="display: none;">
                    <small>API: <span id="current-api">–ù–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω</span></small>
                </div>
                
                <div class="camera-controls">
                    <button id="camera-btn" onclick="startCamera()">üì∑ –í–∫–ª—é—á–∏—Ç—å –∫–∞–º–µ—Ä—É</button>
                    <button id="capture-btn" onclick="captureImage()" style="display: none;">üì∏ –°–¥–µ–ª–∞—Ç—å —Å–Ω–∏–º–æ–∫</button>
                    <button id="stop-camera-btn" onclick="stopCamera()" style="display: none;">‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–∞–º–µ—Ä—É</button>
                    <button id="api-settings-btn" onclick="configureApi()" style="background: #6b7280;">‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ API</button>
                    <button id="test-api-btn" onclick="testApiConnection()" style="background: #059669;">üß™ –¢–µ—Å—Ç API</button>
                </div>
                
                <div class="camera-container" id="camera-container" style="display: none;">
                    <video id="camera-stream" autoplay playsinline></video>
                    <canvas id="capture-canvas" style="display: none;"></canvas>
                </div>
                
                <div class="captured-image" id="captured-image" style="display: none;">
                    <h4>–°–Ω—è—Ç–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ:</h4>
                    <img id="captured-img" style="max-width: 100%; border-radius: 8px;">
                    <div class="image-controls">
                        <button onclick="processImage()">üîç –†–∞—Å–ø–æ–∑–Ω–∞—Ç—å –ø–æ–∫–∞–∑–∞–Ω–∏—è</button>
                        <button onclick="retakePhoto()">üîÑ –ü–µ—Ä–µ—Å–Ω—è—Ç—å</button>
                    </div>
                </div>
                
                <div class="ocr-result" id="ocr-result" style="display: none;">
                    <h4>–†–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–µ –ø–æ–∫–∞–∑–∞–Ω–∏—è:</h4>
                    <div id="ocr-readings"></div>
                    <div class="ocr-actions">
                        <button onclick="useOcrReadings()">üìù –ó–∞–ø–æ–ª–Ω–∏—Ç—å —Ñ–æ—Ä–º—É</button>
                        <button onclick="saveOcrReadings()" style="background: #10b981;">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å—Ä–∞–∑—É</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="readings-section">
                <div class="readings-header">
                    <h2>–í–∞—à–∏ –∏–∑–º–µ—Ä–µ–Ω–∏—è</h2>
                <div class="controls-group">
                    <input type="file" id="csvFileInput" class="file-input" accept=".csv" onchange="importCSV(event)">
                    <button class="secondary-btn import-btn" onclick="document.getElementById('csvFileInput').click()">üì§ –ò–º–ø–æ—Ä—Ç CSV</button>
                    <button class="secondary-btn export-btn" onclick="exportData('csv')">üì• –≠–∫—Å–ø–æ—Ä—Ç CSV</button>
                    <button class="secondary-btn" onclick="clearAllReadings()">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ</button>
                </div>
            </div>

            <div class="stats" id="stats"></div>

            <div class="chart-section" id="chart-section">
                <div class="chart-header">
                    <h3>–ì—Ä–∞—Ñ–∏–∫ —Ç—Ä–µ–Ω–¥–æ–≤</h3>
                    <button class="chart-toggle" id="chart-toggle" onclick="toggleChart()">üìà –ü–æ–∫–∞–∑–∞—Ç—å –≥—Ä–∞—Ñ–∏–∫</button>
                </div>
                <div class="chart-container hidden" id="chart-container">
                    <canvas class="chart-canvas" id="chart-canvas"></canvas>
                    <div class="chart-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ef4444;"></div>
                            <span>–°–∏—Å—Ç–æ–ª–∏—á–µ—Å–∫–æ–µ</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #3b82f6;"></div>
                            <span>–î–∏–∞—Å—Ç–æ–ª–∏—á–µ—Å–∫–æ–µ</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #10b981;"></div>
                            <span>–ü—É–ª—å—Å</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="table-container">
                <div id="readings-table"></div>
            </div>
        </div>

        <elevenlabs-convai agent-id="agent_01jy58kznwf6ct6g8j0mvwmxh3">
            
        </elevenlabs-convai>
        <script src="https://unpkg.com/@elevenlabs/convai-widget-embed" async type="text/javascript"></script>
        

        <div class="footer">
            <div class="copyright">
                Made with ‚ù§Ô∏è by ab2005@gmail.com | ¬© 2025 Blood Pressure Tracker
            </div>
        </div>
    </div>
    </div>

    <script>
        // PWA and Storage Variables
        let readings = [];
        let chartVisible = false;
        let deferredPrompt;
        let db;
        const dbName = 'BPTrackerDB';
        const dbVersion = 1;

        const symptomLabels = {
            headache: '–ì–æ–ª–æ–≤–Ω–∞—è –±–æ–ª—å',
            tinnitus: '–®—É–º –≤ —É—à–∞—Ö',
            dizziness: '–ì–æ–ª–æ–≤–æ–∫—Ä—É–∂–µ–Ω–∏–µ',
            anxiety: '–¢—Ä–µ–≤–æ–∂–Ω–æ—Å—Ç—å',
            poor_sleep: '–ü–ª–æ—Ö–æ–π —Å–æ–Ω',
            alcohol: '–ê–ª–∫–æ–≥–æ–ª—å –Ω–∞–∫–∞–Ω—É–Ω–µ',
            exercise: '–ü–æ—Å–ª–µ –Ω–∞–≥—Ä—É–∑–∫–∏',
            stress: '–°—Ç—Ä–µ—Å—Å',
            fatigue: '–£—Å—Ç–∞–ª–æ—Å—Ç—å',
        };

        // Initialize PWA
        window.addEventListener('load', async () => {
            try {
                await initDB();
                await loadReadings();
                hideLoadingScreen();
                setupPWA();
                setupNotifications();
                setDefaultDateTime();
                updateDisplay();
                updateApiStatus(); // Show current API configuration
            } catch (error) {
                console.error('Initialization error:', error);
                hideLoadingScreen(); // Hide loading screen even if there's an error
            }
        });

        // Hide loading screen
        function hideLoadingScreen() {
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
            }, 1000);
        }

        // IndexedDB Setup
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(dbName, dbVersion);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve();
                };

                request.onupgradeneeded = (event) => {
                    db = event.target.result;

                    // Create readings store
                    if (!db.objectStoreNames.contains('readings')) {
                        const store = db.createObjectStore('readings', { keyPath: 'id' });
                        store.createIndex('timestamp', 'timestamp', { unique: false });
                    }


                };
            });
        }

        // Load readings from IndexedDB
        async function loadReadings() {
            return new Promise((resolve, reject) => {
                if (!db) {
                    // Try to load from localStorage backup
                    try {
                        const backup = localStorage.getItem('bp_readings_backup');
                        if (backup) {
                            readings = JSON.parse(backup);
                            console.log('Loaded readings from localStorage backup');
                        }
                    } catch (e) {
                        console.warn('Could not load from localStorage:', e);
                    }
                    resolve(); // If no db, just resolve
                    return;
                }
                
                const transaction = db.transaction(['readings'], 'readonly');
                const store = transaction.objectStore('readings');
                const request = store.getAll();

                request.onsuccess = () => {
                    readings = request.result || [];
                    
                    // Also check localStorage for any missing readings
                    try {
                        const backup = localStorage.getItem('bp_readings_backup');
                        if (backup) {
                            const backupReadings = JSON.parse(backup);
                            // Merge unique readings
                            backupReadings.forEach(br => {
                                if (!readings.some(r => r.id === br.id)) {
                                    readings.push(br);
                                }
                            });
                        }
                    } catch (e) {
                        console.warn('Could not merge localStorage backup:', e);
                    }
                    
                    readings.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                    resolve();
                };

                request.onerror = () => {
                    console.error('Error loading readings:', request.error);
                    // Try localStorage backup
                    try {
                        const backup = localStorage.getItem('bp_readings_backup');
                        if (backup) {
                            readings = JSON.parse(backup);
                        }
                    } catch (e) {
                        console.warn('Could not load from localStorage:', e);
                    }
                    resolve(); // Resolve anyway to continue initialization
                };
            });
        }

        // Save reading to IndexedDB
        async function saveReading(reading) {
            return new Promise((resolve, reject) => {
                // Check if database is initialized
                if (!db) {
                    console.error('Database not initialized');
                    reject(new Error('–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞'));
                    return;
                }

                try {
                    const transaction = db.transaction(['readings'], 'readwrite');
                    const store = transaction.objectStore('readings');
                    const request = store.add(reading);

                    request.onsuccess = () => {
                        console.log('Reading saved successfully');
                        resolve();
                    };
                    
                    request.onerror = () => {
                        console.error('Error saving reading:', request.error);
                        reject(request.error);
                    };

                    transaction.onerror = () => {
                        console.error('Transaction error:', transaction.error);
                        reject(transaction.error);
                    };

                    transaction.onabort = () => {
                        console.error('Transaction aborted');
                        reject(new Error('–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –ø—Ä–µ—Ä–≤–∞–Ω–∞'));
                    };
                } catch (error) {
                    console.error('Error creating transaction:', error);
                    reject(error);
                }
            });
        }

        // Delete reading from IndexedDB
        async function deleteReadingFromDB(id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['readings'], 'readwrite');
                const store = transaction.objectStore('readings');
                const request = store.delete(id);

                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // Clear all readings from IndexedDB
        async function clearAllReadingsFromDB() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['readings'], 'readwrite');
                const store = transaction.objectStore('readings');
                const request = store.clear();

                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // Service Worker Registration
        function setupPWA() {
            if ('serviceWorker' in navigator) {
                // Register service worker with inline code
                const swCode = `
                    const CACHE_NAME = 'bp-tracker-v1';
                    const urlsToCache = ['/'];

                    self.addEventListener('install', (event) => {
                        event.waitUntil(
                            caches.open(CACHE_NAME)
                                .then((cache) => cache.addAll(urlsToCache))
                        );
                    });

                    self.addEventListener('fetch', (event) => {
                        event.respondWith(
                            caches.match(event.request)
                                .then((response) => response || fetch(event.request))
                        );
                    });

                    self.addEventListener('notificationclick', (event) => {
                        event.notification.close();
                        event.waitUntil(
                            clients.openWindow('/')
                        );
                    });
                `;

                const blob = new Blob([swCode], { type: 'application/javascript' });
                const swUrl = URL.createObjectURL(blob);

                navigator.serviceWorker.register(swUrl)
                    .then(() => console.log('Service Worker registered'))
                    .catch(err => console.log('Service Worker registration failed'));
            }

            // PWA Install Banner
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
                showInstallBanner();
            });
        }

        function showInstallBanner() {
            document.getElementById('install-banner').style.display = 'block';
        }

        function installPWA() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        dismissInstallBanner();
                    }
                    deferredPrompt = null;
                });
            }
        }

        function dismissInstallBanner() {
            document.getElementById('install-banner').style.display = 'none';
        }

        // Notifications Setup
        function setupNotifications() {
            // Basic notification setup
            if ('Notification' in window) {
                Notification.requestPermission();
            }
        }

        async function requestNotificationPermission() {
            if ('Notification' in window) {
                const permission = await Notification.requestPermission();
                return permission === 'granted';
            }
            return false;
        }


        function testNotification() {
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification('–¢—Ä–µ–∫–µ—Ä –¥–∞–≤–ª–µ–Ω–∏—è', {
                    body: '–í—Ä–µ–º—è –∏–∑–º–µ—Ä–∏—Ç—å –∞—Ä—Ç–µ—Ä–∏–∞–ª—å–Ω–æ–µ –¥–∞–≤–ª–µ–Ω–∏–µ!',
                    icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgdmlld0JveD0iMCAwIDI1NiAyNTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJncmFkIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIxMDAlIj48c3RvcCBvZmZzZXQ9IjAlIiBzdHlsZT0ic3RvcC1jb2xvcjo2NjdlZWE7c3RvcC1vcGFjaXR5OjEiIC8+PHN0b3Agb2Zmc2V0PSIxMDAlIiBzdHlsZT0ic3RvcC1jb2xvcjo3NjRiYTI7c3RvcC1vcGFjaXR5OjEiIC8+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PGNpcmNsZSBjeD0iMTI4IiBjeT0iMTI4IiByPSIxMjgiIGZpbGw9InVybCgjZ3JhZCkiLz48dGV4dCB4PSI2NCIgeT0iMTU2IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSJ3aGl0ZSIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjQ4IiBmb250LXdlaWdodD0iYm9sZCI+ODg8L3RleHQ+PC9zdmc+',
                    badge: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgdmlld0JveD0iMCAwIDI1NiAyNTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJncmFkIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIxMDAlIj48c3RvcCBvZmZzZXQ9IjAlIiBzdHlsZT0ic3RvcC1jb2xvcjo2NjdlZWE7c3RvcC1vcGFjaXR5OjEiIC8+PHN0b3Agb2Zmc2V0PSIxMDAlIiBzdHlsZT0ic3RvcC1jb2xvcjo3NjRiYTI7c3RvcC1vcGFjaXR5OjEiIC8+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PGNpcmNsZSBjeD0iMTI4IiBjeT0iMTI4IiByPSIxMjgiIGZpbGw9InVybCgjZ3JhZCkiLz48dGV4dCB4PSI2NCIgeT0iMTU2IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSJ3aGl0ZSIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjQ4IiBmb250LXdlaWdodD0iYm9sZCI+ODg8L3RleHQ+PC9zdmc+'
                });
            } else {
                alert('–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è –∏–ª–∏ –Ω–µ —Ä–∞–∑—Ä–µ—à–µ–Ω—ã');
            }
        }


        // Set default date and time
        function setDefaultDateTime() {
            document.getElementById('date').valueAsDate = new Date();

            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            document.getElementById('time').value = `${hours}:${minutes}`;
        }

        function getSelectedSymptoms() {
            const symptoms = [];
            Object.keys(symptomLabels).forEach(id => {
                if (document.getElementById(id).checked) {
                    symptoms.push(id);
                }
            });
            return symptoms;
        }


        async function addReading() {
            const date = document.getElementById('date').value;
            const time = document.getElementById('time').value;
            const systolic = parseInt(document.getElementById('systolic').value);
            const diastolic = parseInt(document.getElementById('diastolic').value);
            const pulseInput = document.getElementById('pulse').value;
            const pulse = pulseInput ? parseInt(pulseInput) : null;
            const notes = document.getElementById('notes').value;
            const symptoms = getSelectedSymptoms();

            if (!date || !time || !systolic || !diastolic) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è (–î–∞—Ç–∞, –í—Ä–µ–º—è, –ê—Ä—Ç–µ—Ä–∏–∞–ª—å–Ω–æ–µ –¥–∞–≤–ª–µ–Ω–∏–µ)');
                return;
            }

            if (systolic <= diastolic) {
                alert('–°–∏—Å—Ç–æ–ª–∏—á–µ—Å–∫–æ–µ –¥–∞–≤–ª–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤—ã—à–µ –¥–∏–∞—Å—Ç–æ–ª–∏—á–µ—Å–∫–æ–≥–æ');
                return;
            }

            const reading = {
                id: Date.now(),
                date,
                time,
                systolic,
                diastolic,
                pulse,
                notes: notes || '',
                symptoms,
                timestamp: new Date(`${date}T${time}`)
            };

            try {
                // Check if database is available
                if (db) {
                    await saveReading(reading);
                } else {
                    console.warn('Database not available, saving to memory only');
                }
                
                // Always add to in-memory array
                readings.push(reading);
                readings.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                updateDisplay();
                clearForm();

                // Try to save to localStorage as backup
                try {
                    localStorage.setItem('bp_readings_backup', JSON.stringify(readings));
                } catch (e) {
                    console.warn('Could not save to localStorage:', e);
                }

                // Show success message
                showToast('–ò–∑–º–µ—Ä–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ!', 'success');
            } catch (error) {
                console.error('Error saving reading:', error);
                
                // If IndexedDB fails, still try to save in memory
                if (!readings.some(r => r.id === reading.id)) {
                    readings.push(reading);
                    readings.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                    updateDisplay();
                    clearForm();
                    
                    // Try localStorage backup
                    try {
                        localStorage.setItem('bp_readings_backup', JSON.stringify(readings));
                    } catch (e) {
                        console.warn('Could not save to localStorage:', e);
                    }
                    
                    showToast('–ò–∑–º–µ—Ä–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤—Ä–µ–º–µ–Ω–Ω–æ (–ø—Ä–æ–±–ª–µ–º–∞ —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö)', 'info');
                } else {
                    showToast('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏', 'error');
                }
            }
        }

        function clearForm() {
            document.getElementById('systolic').value = '';
            document.getElementById('diastolic').value = '';
            document.getElementById('pulse').value = '';
            document.getElementById('notes').value = '';
            clearSymptoms();

            // Reset to current time for next entry
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            document.getElementById('time').value = `${hours}:${minutes}`;
        }

        function clearSymptoms() {
            Object.keys(symptomLabels).forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.checked = false;
                    checkbox.parentElement.classList.remove('selected');
                }
            });
        }

        function toggleSymptom(symptomId) {
            const checkbox = document.getElementById(symptomId);
            const symptomItem = checkbox.parentElement;
            
            checkbox.checked = !checkbox.checked;
            
            if (checkbox.checked) {
                symptomItem.classList.add('selected');
            } else {
                symptomItem.classList.remove('selected');
            }
        }

        async function deleteReading(id) {
            if (confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —ç—Ç–æ –∏–∑–º–µ—Ä–µ–Ω–∏–µ?')) {
                try {
                    await deleteReadingFromDB(id);
                    readings = readings.filter(r => r.id !== id);
                    updateDisplay();
                    showToast('–ò–∑–º–µ—Ä–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–æ', 'success');
                } catch (error) {
                    console.error('Error deleting reading:', error);
                    showToast('–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏', 'error');
                }
            }
        }

        async function clearAllReadings() {
            if (readings.length === 0) return;

            if (confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å –≤—Å–µ –∏–∑–º–µ—Ä–µ–Ω–∏—è? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–ª—å–∑—è –æ—Ç–º–µ–Ω–∏—Ç—å.')) {
                try {
                    await clearAllReadingsFromDB();
                    readings = [];
                    updateDisplay();
                    showToast('–í—Å–µ –∏–∑–º–µ—Ä–µ–Ω–∏—è —É–¥–∞–ª–µ–Ω—ã', 'success');
                } catch (error) {
                    console.error('Error clearing readings:', error);
                    showToast('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –¥–∞–Ω–Ω—ã—Ö', 'error');
                }
            }
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                border-radius: 8px;
                color: white;
                font-weight: 600;
                z-index: 1000;
                opacity: 0;
                transition: opacity 0.3s ease;
                ${type === 'success' ? 'background: #10b981;' : ''}
                ${type === 'error' ? 'background: #ef4444;' : ''}
                ${type === 'info' ? 'background: #3b82f6;' : ''}
            `;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => toast.style.opacity = '1', 100);
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => document.body.removeChild(toast), 300);
            }, 3000);
        }

        function exportData(format) {
            if (readings.length === 0) {
                alert('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞');
                return;
            }

            const headers = ['–î–∞—Ç–∞', '–í—Ä–µ–º—è', '–°–∏—Å—Ç–æ–ª–∏—á–µ—Å–∫–æ–µ', '–î–∏–∞—Å—Ç–æ–ª–∏—á–µ—Å–∫–æ–µ', '–ü—É–ª—å—Å', '–°–∏–º–ø—Ç–æ–º—ã', '–ó–∞–º–µ—Ç–∫–∏'];
            const csvContent = [
                headers.join(','),
                ...readings.map(r => {
                    const symptomsText = r.symptoms ? r.symptoms.map(s => symptomLabels[s]).join('; ') : '';
                    return [
                        r.date,
                        r.time,
                        r.systolic,
                        r.diastolic,
                        r.pulse || '',
                        `"${symptomsText}"`,
                        `"${r.notes.replace(/"/g, '""')}"`
                    ].join(',');
                })
            ].join('\n');

            const content = '\uFEFF' + csvContent; // BOM for Excel compatibility
            const filename = `blood_pressure_${new Date().toISOString().split('T')[0]}.csv`;
            const mimeType = 'text/csv;charset=utf-8;';

            const blob = new Blob([content], { type: mimeType });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
            URL.revokeObjectURL(link.href);

            showToast('–î–∞–Ω–Ω—ã–µ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã!', 'success');
        }

        async function importCSV(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const csv = e.target.result;
                    const lines = csv.split('\n');

                    if (lines.length < 2) {
                        alert('CSV —Ñ–∞–π–ª –ø—É—Å—Ç –∏–ª–∏ –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç');
                        return;
                    }

                    // Skip header line
                    const dataLines = lines.slice(1).filter(line => line.trim());
                    let importedCount = 0;

                    for (const line of dataLines) {
                        const values = parseCSVLine(line);
                        if (values.length >= 4) {
                            const [date, time, systolic, diastolic, pulse, symptomsText, notes] = values;

                            if (date && time && systolic && diastolic) {
                                // Parse symptoms
                                const symptoms = [];
                                if (symptomsText) {
                                    const symptomTexts = symptomsText.split(';').map(s => s.trim());
                                    symptomTexts.forEach(symptomText => {
                                        const symptomKey = Object.keys(symptomLabels).find(key =>
                                            symptomLabels[key] === symptomText
                                        );
                                        if (symptomKey) {
                                            symptoms.push(symptomKey);
                                        }
                                    });
                                }

                                const reading = {
                                    id: Date.now() + Math.random(), // Unique ID
                                    date,
                                    time,
                                    systolic: parseInt(systolic),
                                    diastolic: parseInt(diastolic),
                                    pulse: pulse ? parseInt(pulse) : null,
                                    notes: notes || '',
                                    symptoms,
                                    timestamp: new Date(`${date}T${time}`)
                                };

                                // Check if reading already exists (same date/time)
                                const exists = readings.some(r =>
                                    r.date === reading.date && r.time === reading.time
                                );

                                if (!exists) {
                                    await saveReading(reading);
                                    readings.push(reading);
                                    importedCount++;
                                }
                            }
                        }
                    }

                    if (importedCount > 0) {
                        readings.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                        updateDisplay();
                        showToast(`–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ ${importedCount} –∏–∑–º–µ—Ä–µ–Ω–∏–π`, 'success');
                    } else {
                        alert('–ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–æ—Ä–º–∞—Ç CSV —Ñ–∞–π–ª–∞.');
                    }

                } catch (error) {
                    console.error('Import error:', error);
                    alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ CSV —Ñ–∞–π–ª–∞: ' + error.message);
                }
            };

            reader.readAsText(file, 'utf-8');
            event.target.value = ''; // Reset file input
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];

                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        current += '"';
                        i++; // Skip next quote
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }

            result.push(current.trim());
            return result;
        }

        function toggleChart() {
            const container = document.getElementById('chart-container');
            const button = document.getElementById('chart-toggle');

            chartVisible = !chartVisible;

            if (chartVisible) {
                container.classList.remove('hidden');
                button.textContent = 'üìâ –°–∫—Ä—ã—Ç—å –≥—Ä–∞—Ñ–∏–∫';
                drawChart();
            } else {
                container.classList.add('hidden');
                button.textContent = 'üìà –ü–æ–∫–∞–∑–∞—Ç—å –≥—Ä–∞—Ñ–∏–∫';
            }
        }

        function drawChart() {
            if (readings.length < 2) return;

            const canvas = document.getElementById('chart-canvas');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            const container = canvas.parentElement;
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Sort readings chronologically for chart
            const sortedReadings = [...readings].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            // Calculate chart dimensions
            const margin = { top: 20, right: 20, bottom: 50, left: 50 };
            const chartWidth = canvas.width - margin.left - margin.right;
            const chartHeight = canvas.height - margin.top - margin.bottom;

            // Find data ranges
            const systolicValues = sortedReadings.map(r => r.systolic);
            const diastolicValues = sortedReadings.map(r => r.diastolic);
            const pulseValues = sortedReadings.filter(r => r.pulse).map(r => r.pulse);

            const minValue = Math.min(...systolicValues, ...diastolicValues, ...pulseValues) - 10;
            const maxValue = Math.max(...systolicValues, ...diastolicValues, ...pulseValues) + 10;

            // Draw grid
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 1;

            // Horizontal grid lines
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartHeight * i / 10);
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(margin.left + chartWidth, y);
                ctx.stroke();

                // Y-axis labels
                const value = Math.round(maxValue - ((maxValue - minValue) * i / 10));
                ctx.fillStyle = '#6b7280';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(value, margin.left - 5, y + 4);
            }

            // Vertical grid lines
            for (let i = 0; i < sortedReadings.length; i++) {
                const x = margin.left + (chartWidth * i / (sortedReadings.length - 1));
                ctx.strokeStyle = '#e5e7eb';
                ctx.beginPath();
                ctx.moveTo(x, margin.top);
                ctx.lineTo(x, margin.top + chartHeight);
                ctx.stroke();

                // X-axis labels (dates)
                if (i % Math.ceil(sortedReadings.length / 5) === 0) {
                    const date = new Date(sortedReadings[i].timestamp).toLocaleDateString('ru-RU', {
                        month: 'short',
                        day: 'numeric'
                    });
                    ctx.fillStyle = '#6b7280';
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(date, x, canvas.height - 15);
                }
            }

            // Draw lines
            function drawLine(values, color, getData) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.beginPath();

                let started = false;
                for (let i = 0; i < sortedReadings.length; i++) {
                    const reading = sortedReadings[i];
                    const value = getData(reading);

                    if (value !== null && value !== undefined) {
                        const x = margin.left + (chartWidth * i / (sortedReadings.length - 1));
                        const y = margin.top + chartHeight - ((value - minValue) / (maxValue - minValue)) * chartHeight;

                        if (!started) {
                            ctx.moveTo(x, y);
                            started = true;
                        } else {
                            ctx.lineTo(x, y);
                        }

                        // Draw points
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
                ctx.stroke();
            }

            // Draw systolic line
            drawLine(systolicValues, '#ef4444', r => r.systolic);

            // Draw diastolic line
            drawLine(diastolicValues, '#3b82f6', r => r.diastolic);

            // Draw pulse line
            drawLine(pulseValues, '#10b981', r => r.pulse);
        }

        function getBPCategory(systolic, diastolic) {
            if (systolic < 120 && diastolic < 80) return { category: '–ù–æ—Ä–º–∞–ª—å–Ω–æ–µ', class: 'bp-normal' };
            if ((systolic >= 120 && systolic <= 129) && diastolic < 80) return { category: '–ü–æ–≤—ã—à–µ–Ω–Ω–æ–µ', class: 'bp-elevated' };
            if ((systolic >= 130 && systolic <= 139) || (diastolic >= 80 && diastolic <= 89)) return { category: '–í—ã—Å–æ–∫–æ–µ 1 —Å—Ç.', class: 'bp-high' };
            if (systolic >= 140 || diastolic >= 90) return { category: '–í—ã—Å–æ–∫–æ–µ 2 —Å—Ç.', class: 'bp-high' };
            if (systolic > 180 || diastolic > 120) return { category: '–ö—Ä–∏—Ç–∏—á–µ—Å–∫–æ–µ', class: 'bp-high' };
            return { category: '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ', class: '' };
        }

        function updateDisplay() {
            updateStats();
            updateTable();
            if (chartVisible) {
                setTimeout(drawChart, 100); // Small delay to ensure DOM is updated
            }
        }

        function updateStats() {
            const statsDiv = document.getElementById('stats');

            if (readings.length === 0) {
                statsDiv.innerHTML = '';
                return;
            }

            const avgSystolic = Math.round(readings.reduce((sum, r) => sum + r.systolic, 0) / readings.length);
            const avgDiastolic = Math.round(readings.reduce((sum, r) => sum + r.diastolic, 0) / readings.length);

            // Fixed pulse calculation - only include readings that have pulse values
            const readingsWithPulse = readings.filter(r => r.pulse !== null && r.pulse !== undefined);
            const avgPulse = readingsWithPulse.length > 0 ?
                Math.round(readingsWithPulse.reduce((sum, r) => sum + r.pulse, 0) / readingsWithPulse.length) : '–ù/–î';

            const latest = readings[0];
            const latestCategory = getBPCategory(latest.systolic, latest.diastolic);

            statsDiv.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${readings.length}</div>
                    <div class="stat-label">–í—Å–µ–≥–æ –∏–∑–º–µ—Ä–µ–Ω–∏–π</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${avgSystolic}/${avgDiastolic}</div>
                    <div class="stat-label">–°—Ä–µ–¥–Ω–µ–µ –ê–î</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${avgPulse}</div>
                    <div class="stat-label">–°—Ä–µ–¥–Ω–∏–π –ø—É–ª—å—Å</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value ${latestCategory.class}">${latestCategory.category}</div>
                    <div class="stat-label">–ü–æ—Å–ª–µ–¥–Ω—è—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è</div>
                </div>
            `;
        }

        function updateTable() {
            const tableDiv = document.getElementById('readings-table');

            if (readings.length === 0) {
                tableDiv.innerHTML = '<div class="no-data">–ò–∑–º–µ—Ä–µ–Ω–∏—è –µ—â—ë –Ω–µ –∑–∞–ø–∏—Å–∞–Ω—ã. –î–æ–±–∞–≤—å—Ç–µ –≤–∞—à–µ –ø–µ—Ä–≤–æ–µ –∏–∑–º–µ—Ä–µ–Ω–∏–µ –≤—ã—à–µ!</div>';
                return;
            }

            let tableHTML = `
                <table>
                    <thead>
                        <tr>
                            <th>–î–∞—Ç–∞</th>
                            <th>–í—Ä–µ–º—è</th>
                            <th>–ê–î</th>
                            <th>–ö–∞—Ç–µ–≥–æ—Ä–∏—è</th>
                            <th>–ü—É–ª—å—Å</th>
                            <th>–°–∏–º–ø—Ç–æ–º—ã</th>
                            <th>–ó–∞–º–µ—Ç–∫–∏</th>
                            <th>–î–µ–π—Å—Ç–≤–∏–µ</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            readings.forEach(reading => {
                const category = getBPCategory(reading.systolic, reading.diastolic);
                const formattedDate = new Date(reading.timestamp).toLocaleDateString('ru-RU');
                
                // Debug logging for symptoms
                console.log('Reading symptoms:', reading.symptoms);
                console.log('Symptom labels available:', symptomLabels);
                
                const symptomsText = reading.symptoms && reading.symptoms.length > 0
                    ? reading.symptoms.map(s => {
                        const label = symptomLabels[s];
                        console.log(`Mapping symptom '${s}' to '${label}'`);
                        return label || s; // Fallback to symptom key if label not found
                    }).filter(Boolean).join(', ')
                    : '-';

                tableHTML += `
                    <tr>
                        <td>${formattedDate}</td>
                        <td>${reading.time}</td>
                        <td class="bp-reading ${category.class}">${reading.systolic}/${reading.diastolic}</td>
                        <td><span class="${category.class}">${category.category}</span></td>
                        <td>${reading.pulse || '-'}</td>
                        <td class="symptoms-display" title="${symptomsText}">${symptomsText}</td>
                        <td>${reading.notes || '-'}</td>
                        <td><button class="delete-btn" onclick="deleteReading(${reading.id})">–£–¥–∞–ª–∏—Ç—å</button></td>
                    </tr>
                `;
            });

            tableHTML += '</tbody></table>';
            tableDiv.innerHTML = tableHTML;
        }


        // Redraw chart on window resize
        window.addEventListener('resize', () => {
            if (chartVisible) {
                setTimeout(drawChart, 100);
            }
        });

        // Camera Functionality
        let cameraStream = null;
        let capturedImageData = null;

        async function startCamera() {
            try {
                const constraints = {
                    video: {
                        facingMode: 'environment', // Use back camera on mobile
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                };

                cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                const video = document.getElementById('camera-stream');
                video.srcObject = cameraStream;

                // Show/hide UI elements
                document.getElementById('camera-container').style.display = 'block';
                document.getElementById('capture-btn').style.display = 'inline-block';
                document.getElementById('stop-camera-btn').style.display = 'inline-block';
                document.getElementById('camera-btn').style.display = 'none';

                // Hide previous results
                document.getElementById('captured-image').style.display = 'none';
                document.getElementById('ocr-result').style.display = 'none';

            } catch (error) {
                console.error('Error accessing camera:', error);
                alert('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫–∞–º–µ—Ä—ã –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ.');
            }
        }

        function stopCamera() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }

            // Reset UI
            document.getElementById('camera-container').style.display = 'none';
            document.getElementById('capture-btn').style.display = 'none';
            document.getElementById('stop-camera-btn').style.display = 'none';
            document.getElementById('camera-btn').style.display = 'inline-block';
        }

        function captureImage() {
            const video = document.getElementById('camera-stream');
            const canvas = document.getElementById('capture-canvas');
            const ctx = canvas.getContext('2d');

            // Set canvas dimensions to match video
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            // Draw video frame to canvas
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            // Convert to base64
            capturedImageData = canvas.toDataURL('image/jpeg', 0.8);

            // Show captured image
            const capturedImg = document.getElementById('captured-img');
            capturedImg.src = capturedImageData;
            document.getElementById('captured-image').style.display = 'block';

            // Stop camera
            stopCamera();
        }

        function retakePhoto() {
            document.getElementById('captured-image').style.display = 'none';
            document.getElementById('ocr-result').style.display = 'none';
            startCamera();
        }

        async function processImage() {
            if (!capturedImageData) {
                alert('–°–Ω–∞—á–∞–ª–∞ —Å–¥–µ–ª–∞–π—Ç–µ —Å–Ω–∏–º–æ–∫');
                return;
            }

            // Show loading overlay
            showLoading('–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –ø–æ–∫–∞–∑–∞–Ω–∏–π...');

            try {
                // Get API configuration
                const apiConfig = await getApiConfiguration();
                
                // Prepare the request based on API provider
                const requestData = prepareApiRequest(apiConfig, capturedImageData);
                
                // Handle Google API key in URL
                let endpoint = apiConfig.endpoint;
                if (apiConfig.provider === 'google') {
                    endpoint += `?key=${apiConfig.apiKey}`;
                }
                
                console.log('API Request:', {
                    provider: apiConfig.provider,
                    endpoint: endpoint,
                    headers: requestData.headers,
                    bodySize: requestData.body?.length || 0
                });
                
                const response = await fetch(endpoint, requestData);

                hideLoading();

                if (!response.ok) {
                    let errorDetails = `${response.status} - ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        console.error('API Error Response:', errorData);
                        errorDetails += `\n–î–µ—Ç–∞–ª–∏: ${JSON.stringify(errorData, null, 2)}`;
                    } catch (e) {
                        const errorText = await response.text();
                        console.error('API Error Text:', errorText);
                        errorDetails += `\n–û—Ç–≤–µ—Ç: ${errorText}`;
                    }
                    throw new Error(`API Error: ${errorDetails}`);
                }

                const data = await response.json();
                console.log('API Response:', data);
                const ocrText = extractTextFromApiResponse(data, apiConfig.provider);

                // Parse OCR result
                const parsedReadings = parseOcrReadings(ocrText);
                
                if (parsedReadings) {
                    displayOcrResult(ocrText, parsedReadings);
                } else {
                    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –ø–æ–∫–∞–∑–∞–Ω–∏—è –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏');
                }

            } catch (error) {
                hideLoading();
                console.error('OCR Error:', error);
                
                // Show detailed error information
                let errorMessage = '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–∏: ' + error.message;
                
                if (error.message.includes('API Error:')) {
                    const config = JSON.parse(localStorage.getItem('llm_api_config') || '{}');
                    errorMessage = `–û—à–∏–±–∫–∞ API (${config.provider || '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}): ${error.message}\n\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ:\n1. –ü—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å API –∫–ª—é—á–∞\n2. –î–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Å–µ—Ä–≤–∏—Å–∞\n3. –õ–∏–º–∏—Ç—ã API\n\n–ù–∞–∂–º–∏—Ç–µ ‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ API –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏.`;
                }
                
                alert(errorMessage);
            }
        }

        function parseOcrReadings(ocrText) {
            try {
                // Extract numbers from OCR text
                const systolicMatch = ocrText.match(/—Å–∏—Å—Ç–æ–ª–∏—á–µ—Å–∫–æ–µ?:\s*(\d+)/i) || ocrText.match(/(\d{2,3})\/\d{2,3}/) || ocrText.match(/(\d{2,3})\s+\d{2,3}/);
                const diastolicMatch = ocrText.match(/–¥–∏–∞—Å—Ç–æ–ª–∏—á–µ—Å–∫–æ–µ?:\s*(\d+)/i) || ocrText.match(/\d{2,3}\/(\d{2,3})/) || ocrText.match(/\d{2,3}\s+(\d{2,3})/);
                const pulseMatch = ocrText.match(/–ø—É–ª—å—Å:\s*(\d+)/i) || ocrText.match(/–ø—É–ª—å—Å\s+(\d+)/i) || ocrText.match(/(\d{2,3})\s*—É–¥/i);

                if (systolicMatch && diastolicMatch) {
                    return {
                        systolic: parseInt(systolicMatch[1]),
                        diastolic: parseInt(diastolicMatch[1]),
                        pulse: pulseMatch ? parseInt(pulseMatch[1]) : null
                    };
                }
                return null;
            } catch (error) {
                console.error('Error parsing OCR:', error);
                return null;
            }
        }

        function displayOcrResult(ocrText, readings) {
            const ocrResultDiv = document.getElementById('ocr-result');
            const ocrReadingsDiv = document.getElementById('ocr-readings');
            
            ocrReadingsDiv.textContent = `–†–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç: ${ocrText}\n\n–ò–∑–≤–ª–µ—á–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è:\n–°–∏—Å—Ç–æ–ª–∏—á–µ—Å–∫–æ–µ: ${readings.systolic}\n–î–∏–∞—Å—Ç–æ–ª–∏—á–µ—Å–∫–æ–µ: ${readings.diastolic}\n–ü—É–ª—å—Å: ${readings.pulse || '–Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω'}`;
            
            ocrResultDiv.style.display = 'block';
            
            // Store readings for use
            window.recognizedReadings = readings;
        }

        function useOcrReadings() {
            if (!window.recognizedReadings) {
                alert('–ù–µ—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã—Ö –ø–æ–∫–∞–∑–∞–Ω–∏–π');
                return;
            }

            const readings = window.recognizedReadings;
            
            // Fill form fields
            document.getElementById('systolic').value = readings.systolic;
            document.getElementById('diastolic').value = readings.diastolic;
            if (readings.pulse) {
                document.getElementById('pulse').value = readings.pulse;
            }

            // Scroll to form
            document.getElementById('systolic').scrollIntoView({ behavior: 'smooth' });
            
            // Hide OCR result
            document.getElementById('ocr-result').style.display = 'none';
            document.getElementById('captured-image').style.display = 'none';

            showToast('–ü–æ–∫–∞–∑–∞–Ω–∏—è –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω—ã –≤ —Ñ–æ—Ä–º—É', 'success');
        }

        async function saveOcrReadings() {
            if (!window.recognizedReadings) {
                alert('–ù–µ—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã—Ö –ø–æ–∫–∞–∑–∞–Ω–∏–π');
                return;
            }

            const ocrReadings = window.recognizedReadings;

            // Get current date and time
            const now = new Date();
            const date = now.toISOString().split('T')[0];
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const time = `${hours}:${minutes}`;

            // Create reading object
            const reading = {
                id: Date.now(),
                date,
                time,
                systolic: ocrReadings.systolic,
                diastolic: ocrReadings.diastolic,
                pulse: ocrReadings.pulse,
                notes: '–î–æ–±–∞–≤–ª–µ–Ω–æ —á–µ—Ä–µ–∑ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–∞–º–µ—Ä—ã',
                symptoms: [], // No symptoms from OCR
                timestamp: new Date(`${date}T${time}`)
            };

            try {
                // Check if database is available
                if (db) {
                    await saveReading(reading);
                } else {
                    console.warn('Database not available, saving to memory only');
                }
                
                // Always add to in-memory array
                readings.push(reading);
                readings.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                // Update display
                updateDisplay();

                // Hide OCR result and captured image
                document.getElementById('ocr-result').style.display = 'none';
                document.getElementById('captured-image').style.display = 'none';
                
                // Clear OCR readings
                window.recognizedReadings = null;

                // Try to save to localStorage as backup
                try {
                    localStorage.setItem('bp_readings_backup', JSON.stringify(readings));
                } catch (e) {
                    console.warn('Could not save to localStorage:', e);
                }

                // Show success message
                showToast('–ò–∑–º–µ—Ä–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ —á–µ—Ä–µ–∑ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–∞–º–µ—Ä—ã!', 'success');
                
                // Update form date/time for next entry
                document.getElementById('date').value = date;
                document.getElementById('time').value = time;
                
            } catch (error) {
                console.error('Error saving OCR reading:', error);
                
                // If IndexedDB fails, still try to save in memory
                if (!readings.some(r => r.id === reading.id)) {
                    readings.push(reading);
                    readings.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                    updateDisplay();
                    
                    // Try localStorage backup
                    try {
                        localStorage.setItem('bp_readings_backup', JSON.stringify(readings));
                    } catch (e) {
                        console.warn('Could not save to localStorage:', e);
                    }
                    
                    // Hide UI elements
                    document.getElementById('ocr-result').style.display = 'none';
                    document.getElementById('captured-image').style.display = 'none';
                    window.recognizedReadings = null;
                    document.getElementById('date').value = date;
                    document.getElementById('time').value = time;
                    
                    showToast('–ò–∑–º–µ—Ä–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤—Ä–µ–º–µ–Ω–Ω–æ (–ø—Ä–æ–±–ª–µ–º–∞ —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö)', 'info');
                } else {
                    showToast('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏', 'error');
                }
            }
        }

        async function getApiConfiguration() {
            // Check for saved configuration
            let config = JSON.parse(localStorage.getItem('llm_api_config') || '{}');
            
            // If no configuration exists, show setup dialog
            if (!config.provider || !config.apiKey) {
                config = await showApiConfigurationDialog();
            }
            
            return config;
        }

        async function showApiConfigurationDialog() {
            const provider = prompt(
                '–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–æ–≤–∞–π–¥–µ—Ä LLM API:\n' +
                '1. OpenAI (gpt-4o –∏–ª–∏ gpt-4o-mini)\n' +
                '2. Anthropic Claude (claude-3-5-sonnet-20241022)\n' +
                '3. Google Gemini (gemini-1.5-flash)\n' +
                '4. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π API\n\n' +
                '–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä (1-4):'
            );

            let config = {};
            
            switch(provider) {
                case '1':
                    const openaiModel = prompt(
                        '–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å OpenAI:\n' +
                        '1. gpt-4o (–ª—É—á—à–µ–µ –∫–∞—á–µ—Å—Ç–≤–æ)\n' +
                        '2. gpt-4o-mini (–±—ã—Å—Ç—Ä–µ–µ –∏ –¥–µ—à–µ–≤–ª–µ)\n\n' +
                        '–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä (1-2):'
                    );
                    config = {
                        provider: 'openai',
                        endpoint: 'https://api.openai.com/v1/chat/completions',
                        model: openaiModel === '2' ? 'gpt-4o-mini' : 'gpt-4o'
                    };
                    break;
                case '2':
                    config = {
                        provider: 'anthropic',
                        endpoint: 'https://api.anthropic.com/v1/messages',
                        model: 'claude-3-5-sonnet-20241022'
                    };
                    break;
                case '3':
                    config = {
                        provider: 'google',
                        endpoint: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent',
                        model: 'gemini-1.5-flash'
                    };
                    break;
                case '4':
                    const customEndpoint = prompt('–í–≤–µ–¥–∏—Ç–µ URL API endpoint:');
                    const customModel = prompt('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏:');
                    config = {
                        provider: 'custom',
                        endpoint: customEndpoint,
                        model: customModel
                    };
                    break;
                default:
                    throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞');
            }

            // Get API key
            const apiKey = prompt(`–í–≤–µ–¥–∏—Ç–µ API –∫–ª—é—á –¥–ª—è ${config.provider}:\n(–ö–ª—é—á –±—É–¥–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω –ª–æ–∫–∞–ª—å–Ω–æ)`);
            if (!apiKey) {
                throw new Error('API –∫–ª—é—á –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω');
            }

            config.apiKey = apiKey.trim();
            
            // Save configuration
            localStorage.setItem('llm_api_config', JSON.stringify(config));
            
            return config;
        }

        function prepareApiRequest(config, imageData) {
            const prompt = '–≠—Ç–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —ç–∫—Ä–∞–Ω–∞ —Ç–æ–Ω–æ–º–µ—Ç—Ä–∞ (–ø—Ä–∏–±–æ—Ä–∞ –¥–ª—è –∏–∑–º–µ—Ä–µ–Ω–∏—è –∞—Ä—Ç–µ—Ä–∏–∞–ª—å–Ω–æ–≥–æ –¥–∞–≤–ª–µ–Ω–∏—è). –ù–∞–π–¥–∏—Ç–µ –∏ –∏–∑–≤–ª–µ–∫–∏—Ç–µ —á–∏—Å–ª–æ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –∞—Ä—Ç–µ—Ä–∏–∞–ª—å–Ω–æ–≥–æ –¥–∞–≤–ª–µ–Ω–∏—è (—Å–∏—Å—Ç–æ–ª–∏—á–µ—Å–∫–æ–µ/–¥–∏–∞—Å—Ç–æ–ª–∏—á–µ—Å–∫–æ–µ) –∏ –ø—É–ª—å—Å–∞. –û—Ç–≤–µ—Ç—å—Ç–µ —Ç–æ–ª—å–∫–æ —á–∏—Å–ª–∞–º–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ: "–°–∏—Å—Ç–æ–ª–∏—á–µ—Å–∫–æ–µ: XXX, –î–∏–∞—Å—Ç–æ–ª–∏—á–µ—Å–∫–æ–µ: XXX, –ü—É–ª—å—Å: XXX" –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ, –µ—Å–ª–∏ –Ω–µ –º–æ–∂–µ—Ç–µ —á–µ—Ç–∫–æ —Ä–∞–∑–ª–∏—á–∏—Ç—å –ø–æ–∫–∞–∑–∞–Ω–∏—è.';

            switch(config.provider) {
                case 'openai':
                    return {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${config.apiKey}`
                        },
                        body: JSON.stringify({
                            model: config.model,
                            messages: [{
                                role: 'user',
                                content: [
                                    { type: 'text', text: prompt },
                                    { type: 'image_url', image_url: { url: imageData } }
                                ]
                            }],
                            max_tokens: 150
                        })
                    };

                case 'anthropic':
                    return {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': config.apiKey,
                            'anthropic-version': '2023-06-01'
                        },
                        body: JSON.stringify({
                            model: config.model,
                            max_tokens: 150,
                            messages: [{
                                role: 'user',
                                content: [
                                    { type: 'text', text: prompt },
                                    { type: 'image', source: { type: 'base64', media_type: 'image/jpeg', data: imageData.split(',')[1] } }
                                ]
                            }]
                        })
                    };

                case 'google':
                    return {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts: [
                                    { text: prompt },
                                    { inline_data: { mime_type: 'image/jpeg', data: imageData.split(',')[1] } }
                                ]
                            }]
                        })
                    };

                case 'custom':
                default:
                    // Generic format - can be customized
                    return {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${config.apiKey}`
                        },
                        body: JSON.stringify({
                            model: config.model,
                            prompt: prompt,
                            image: imageData,
                            max_tokens: 150
                        })
                    };
            }
        }

        function extractTextFromApiResponse(data, provider) {
            switch(provider) {
                case 'openai':
                    return data.choices[0].message.content;
                    
                case 'anthropic':
                    return data.content[0].text;
                    
                case 'google':
                    return data.candidates[0].content.parts[0].text;
                    
                case 'custom':
                default:
                    // Try common response formats
                    return data.text || data.response || data.content || data.choices?.[0]?.text || data.result;
            }
        }

        async function configureApi() {
            try {
                // Clear existing configuration
                localStorage.removeItem('llm_api_config');
                
                // Show configuration dialog
                const config = await showApiConfigurationDialog();
                
                // Update status display
                updateApiStatus();
                
                alert(`API –Ω–∞—Å—Ç—Ä–æ–µ–Ω: ${config.provider.toUpperCase()}\n–ú–æ–¥–µ–ª—å: ${config.model}`);
            } catch (error) {
                console.error('Configuration error:', error);
                alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–µ API: ' + error.message);
            }
        }

        function updateApiStatus() {
            try {
                const config = JSON.parse(localStorage.getItem('llm_api_config') || '{}');
                const statusElement = document.getElementById('api-status');
                const currentApiElement = document.getElementById('current-api');
                
                if (config.provider && config.apiKey) {
                    currentApiElement.textContent = `${config.provider.toUpperCase()} (${config.model})`;
                    statusElement.style.display = 'block';
                } else {
                    currentApiElement.textContent = '–ù–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω';
                    statusElement.style.display = 'none';
                }
            } catch (error) {
                console.error('Error updating API status:', error);
            }
        }

        async function testApiConnection() {
            try {
                const config = JSON.parse(localStorage.getItem('llm_api_config') || '{}');
                
                if (!config.provider || !config.apiKey) {
                    alert('–°–Ω–∞—á–∞–ª–∞ –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ API —á–µ—Ä–µ–∑ ‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ API');
                    return;
                }

                showLoading('–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ API...');

                // Create a simple test image (1x1 pixel base64 image)
                const testImage = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/wA';

                const requestData = prepareApiRequest(config, testImage);
                
                let endpoint = config.endpoint;
                if (config.provider === 'google') {
                    endpoint += `?key=${config.apiKey}`;
                }

                console.log('Testing API connection to:', config.provider);
                
                const response = await fetch(endpoint, requestData);
                
                hideLoading();

                if (response.ok) {
                    alert(`‚úÖ API –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ!\n–ü—Ä–æ–≤–∞–π–¥–µ—Ä: ${config.provider.toUpperCase()}\n–°—Ç–∞—Ç—É—Å: ${response.status}`);
                } else {
                    let errorDetails = `${response.status} - ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        console.error('API Test Error:', errorData);
                        errorDetails += `\n–î–µ—Ç–∞–ª–∏: ${JSON.stringify(errorData, null, 2)}`;
                    } catch (e) {
                        const errorText = await response.text();
                        console.error('API Test Error Text:', errorText);
                        errorDetails += `\n–û—Ç–≤–µ—Ç: ${errorText}`;
                    }
                    alert(`‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ API:\n${errorDetails}`);
                }

            } catch (error) {
                hideLoading();
                console.error('API Test Error:', error);
                alert(`‚ùå –û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è API:\n${error.message}`);
            }
        }

        function showLoading(message) {
            const loadingDiv = document.createElement('div');
            loadingDiv.id = 'ocr-loading';
            loadingDiv.className = 'loading-overlay';
            loadingDiv.innerHTML = `
                <div class="loading-content">
                    <div class="loading-spinner"></div>
                    <p>${message}</p>
                </div>
            `;
            document.body.appendChild(loadingDiv);
        }

        function hideLoading() {
            const loadingDiv = document.getElementById('ocr-loading');
            if (loadingDiv) {
                loadingDiv.remove();
            }
        }

        // Voice Input Functionality
        let recognition = null;
        let isListening = false;
        let voiceReadings = null;
        let silenceTimer = null;
        let lastTranscriptTime = null;
        let isProcessingVoiceInput = false;
        let autoStopTimer = null;

        // Initialize speech recognition
        function initSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                
                recognition.lang = 'ru-RU';
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.maxAlternatives = 1;

                recognition.onstart = () => {
                    isListening = true;
                    isProcessingVoiceInput = false;
                    lastTranscriptTime = Date.now();
                    
                    // Clear any existing timers
                    if (autoStopTimer) {
                        clearTimeout(autoStopTimer);
                        autoStopTimer = null;
                    }
                    
                    document.getElementById('voice-btn').style.display = 'none';
                    document.getElementById('stop-voice-btn').style.display = 'inline-block';
                    document.getElementById('voice-feedback').style.display = 'block';
                    document.getElementById('voice-result').style.display = 'none';
                    document.getElementById('voice-status').textContent = '–°–ª—É—à–∞—é...';
                    
                    // Start silence detection timer
                    startSilenceDetection();
                };

                recognition.onresult = (event) => {
                    let finalTranscript = '';
                    let interimTranscript = '';

                    // Update last transcript time
                    lastTranscriptTime = Date.now();

                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript + ' ';
                        } else {
                            interimTranscript += transcript;
                        }
                    }

                    if (finalTranscript) {
                        // Clear any existing auto-stop timer
                        if (autoStopTimer) {
                            clearTimeout(autoStopTimer);
                            autoStopTimer = null;
                        }
                        
                        // Try to parse the final transcript
                        const parsedReadings = parseVoiceTranscript(finalTranscript);
                        if (parsedReadings && parsedReadings.systolic && parsedReadings.diastolic) {
                            // Always wait 4 seconds after getting valid BP readings with countdown
                            let countdown = 4;
                            document.getElementById('voice-status').textContent = `–ü–æ–ª—É—á–µ–Ω–æ –¥–∞–≤–ª–µ–Ω–∏–µ... –ú–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –ø—É–ª—å—Å –∏ —Å–∏–º–ø—Ç–æ–º—ã (${countdown} —Å–µ–∫)`;
                            
                            // Update countdown every second
                            const countdownInterval = setInterval(() => {
                                countdown--;
                                if (countdown > 0 && isListening) {
                                    document.getElementById('voice-status').textContent = `–ü–æ–ª—É—á–µ–Ω–æ –¥–∞–≤–ª–µ–Ω–∏–µ... –ú–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –ø—É–ª—å—Å –∏ —Å–∏–º–ø—Ç–æ–º—ã (${countdown} —Å–µ–∫)`;
                                }
                            }, 1000);
                            
                            // Set a timer to process after 4 seconds
                            autoStopTimer = setTimeout(() => {
                                clearInterval(countdownInterval);
                                if (isListening && !isProcessingVoiceInput) {
                                    isProcessingVoiceInput = true;
                                    recognition.stop();
                                    setTimeout(() => processVoiceInput(finalTranscript), 100);
                                }
                            }, 4000);
                        }
                    } else if (interimTranscript) {
                        document.getElementById('voice-status').textContent = '–°–ª—É—à–∞—é: ' + interimTranscript;
                        
                        // Check if we have valid BP in interim results to show countdown
                        const parsedReadings = parseVoiceTranscript(interimTranscript);
                        if (parsedReadings && parsedReadings.systolic && parsedReadings.diastolic) {
                            document.getElementById('voice-status').textContent = '–ü–æ–ª—É—á–µ–Ω–æ –¥–∞–≤–ª–µ–Ω–∏–µ... –ú–æ–∂–µ—Ç–µ –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å';
                        }
                    }
                };

                recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    let errorMessage = '–û—à–∏–±–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è';
                    
                    switch(event.error) {
                        case 'no-speech':
                            errorMessage = '–†–µ—á—å –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∞';
                            break;
                        case 'audio-capture':
                            errorMessage = '–ú–∏–∫—Ä–æ—Ñ–æ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω';
                            break;
                        case 'not-allowed':
                            errorMessage = '–î–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É –∑–∞–ø—Ä–µ—â–µ–Ω';
                            break;
                    }
                    
                    document.getElementById('voice-status').textContent = errorMessage;
                    setTimeout(() => stopVoiceInput(), 2000);
                };

                recognition.onend = () => {
                    isListening = false;
                    clearSilenceDetection();
                    
                    // Only reset UI if we're not processing valid input
                    if (!isProcessingVoiceInput) {
                        document.getElementById('voice-btn').style.display = 'inline-block';
                        document.getElementById('stop-voice-btn').style.display = 'none';
                        document.getElementById('voice-feedback').style.display = 'none';
                    }
                };

            } else {
                console.error('Speech recognition not supported');
            }
        }

        function startVoiceInput() {
            if (!recognition) {
                initSpeechRecognition();
            }

            if (!recognition) {
                alert('–ì–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤ –≤–∞—à–µ–º –±—Ä–∞—É–∑–µ—Ä–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Chrome, Safari –∏–ª–∏ Edge.');
                return;
            }

            // Request microphone permission
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(() => {
                    recognition.start();
                })
                .catch((error) => {
                    console.error('Microphone access error:', error);
                    alert('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ.');
                });
        }

        function stopVoiceInput() {
            if (recognition && isListening) {
                recognition.stop();
                document.getElementById('voice-feedback').style.display = 'none';
                clearSilenceDetection();
                
                // Clear auto-stop timer
                if (autoStopTimer) {
                    clearTimeout(autoStopTimer);
                    autoStopTimer = null;
                }
            }
        }

        function startSilenceDetection() {
            // Clear any existing timer
            clearSilenceDetection();
            
            // Check for silence every second
            silenceTimer = setInterval(() => {
                const timeSinceLastTranscript = Date.now() - lastTranscriptTime;
                
                // If no speech for 6 seconds, stop listening (backup timeout)
                if (timeSinceLastTranscript > 6000 && isListening) {
                    document.getElementById('voice-status').textContent = '–¢–∏—à–∏–Ω–∞... –ó–∞–≤–µ—Ä—à–∞—é –∑–∞–ø–∏—Å—å';
                    setTimeout(() => {
                        if (isListening) {
                            recognition.stop();
                        }
                    }, 500);
                }
            }, 1000);
        }

        function clearSilenceDetection() {
            if (silenceTimer) {
                clearInterval(silenceTimer);
                silenceTimer = null;
            }
        }

        function processVoiceInput(transcript) {
            // Clear silence detection
            clearSilenceDetection();
            
            // Display the transcript
            document.getElementById('voice-transcript').textContent = transcript;
            
            // Parse the transcript to extract blood pressure readings
            const parsedReadings = parseVoiceTranscript(transcript);
            
            if (parsedReadings && parsedReadings.systolic && parsedReadings.diastolic) {
                // Valid readings found
                voiceReadings = parsedReadings;
                displayVoiceReadings(parsedReadings);
                document.getElementById('voice-result').style.display = 'block';
                document.getElementById('voice-feedback').style.display = 'none';
                
                // Reset UI
                document.getElementById('voice-btn').style.display = 'inline-block';
                document.getElementById('stop-voice-btn').style.display = 'none';
                isProcessingVoiceInput = false;
            } else {
                // No valid readings found
                document.getElementById('voice-status').textContent = '–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –ø–æ–∫–∞–∑–∞–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.';
                isProcessingVoiceInput = false;
                
                // Reset UI if recognition has ended
                if (!isListening) {
                    document.getElementById('voice-btn').style.display = 'inline-block';
                    document.getElementById('stop-voice-btn').style.display = 'none';
                    document.getElementById('voice-feedback').style.display = 'none';
                }
            }
        }

        function parseVoiceTranscript(transcript) {
            // Normalize the transcript
            const normalized = transcript.toLowerCase().replace(/[,\.]/g, ' ');
            
            // Pattern matching for blood pressure readings
            // Common patterns: "120 –Ω–∞ 80", "–¥–∞–≤–ª–µ–Ω–∏–µ 120 80", "—Å–∏—Å—Ç–æ–ª–∏—á–µ—Å–∫–æ–µ 120 –¥–∏–∞—Å—Ç–æ–ª–∏—á–µ—Å–∫–æ–µ 80"
            let systolic = null;
            let diastolic = null;
            let pulse = null;
            const symptoms = [];

            // Pattern 1: "X –Ω–∞ Y" (most common in Russian)
            const bpPattern1 = /(\d{2,3})\s*–Ω–∞\s*(\d{2,3})/;
            const bpMatch1 = normalized.match(bpPattern1);
            if (bpMatch1) {
                systolic = parseInt(bpMatch1[1]);
                diastolic = parseInt(bpMatch1[2]);
            }

            // Pattern 2: "–¥–∞–≤–ª–µ–Ω–∏–µ X Y" or just "X Y"
            if (!systolic) {
                const bpPattern2 = /(?:–¥–∞–≤–ª–µ–Ω–∏–µ\s*)?(\d{2,3})\s+(\d{2,3})(?:\s|$)/;
                const bpMatch2 = normalized.match(bpPattern2);
                if (bpMatch2) {
                    systolic = parseInt(bpMatch2[1]);
                    diastolic = parseInt(bpMatch2[2]);
                }
            }

            // Pattern for pulse
            const pulsePattern = /–ø—É–ª—å—Å\s*(\d{2,3})|(\d{2,3})\s*(?:—É–¥–∞—Ä|—É–¥–∞—Ä–æ–≤)/;
            const pulseMatch = normalized.match(pulsePattern);
            if (pulseMatch) {
                pulse = parseInt(pulseMatch[1] || pulseMatch[2]);
            }

            // Check for symptoms (multiple symptoms can be detected)
            const symptomKeywords = {
                'headache': ['–≥–æ–ª–æ–≤–Ω–∞—è –±–æ–ª—å', '–±–æ–ª–∏—Ç –≥–æ–ª–æ–≤–∞', '–≥–æ–ª–æ–≤–∞ –±–æ–ª–∏—Ç', '–≥–æ–ª–æ–≤–Ω–æ–π –±–æ–ª–∏', '–≥–æ–ª–æ–≤–Ω—É—é –±–æ–ª—å'],
                'tinnitus': ['—à—É–º –≤ —É—à–∞—Ö', '–∑–≤–æ–Ω –≤ —É—à–∞—Ö', '—É—à–∞—Ö —à—É–º', '–∑–≤–µ–Ω–∏—Ç –≤ —É—à–∞—Ö', '—à—É–º–∏—Ç –≤ —É—à–∞—Ö'],
                'dizziness': ['–≥–æ–ª–æ–≤–æ–∫—Ä—É–∂–µ–Ω–∏–µ', '–∫—Ä—É–∂–∏—Ç—Å—è –≥–æ–ª–æ–≤–∞', '–≥–æ–ª–æ–≤–∞ –∫—Ä—É–∂–∏—Ç—Å—è', '–∫—Ä—É–∂–∏—Ç –≥–æ–ª–æ–≤—É', '–≥–æ–ª–æ–≤–æ–∫—Ä—É–∂–µ–Ω–∏—è'],
                'anxiety': ['—Ç—Ä–µ–≤–æ–∂–Ω–æ—Å—Ç—å', '—Ç—Ä–µ–≤–æ–≥–∞', '–±–µ—Å–ø–æ–∫–æ–π—Å—Ç–≤–æ', '—Ç—Ä–µ–≤–æ–∂–Ω—ã–π', '–≤–æ–ª–Ω—É—é—Å—å', '–Ω–µ—Ä–≤–Ω–∏—á–∞—é'],
                'poor_sleep': ['–ø–ª–æ—Ö–æ–π —Å–æ–Ω', '–Ω–µ –≤—ã—Å–ø–∞–ª—Å—è', '–Ω–µ —Å–ø–∞–ª', '–±–µ—Å—Å–æ–Ω–Ω–∏—Ü–∞', '–ø–ª–æ—Ö–æ —Å–ø–∞–ª', '–º–∞–ª–æ —Å–ø–∞–ª', '–Ω–µ –≤—ã—Å—ã–ø–∞–ª—Å—è'],
                'alcohol': ['–∞–ª–∫–æ–≥–æ–ª—å', '–≤—ã–ø–∏–≤–∞–ª', '–ø–∏–ª –≤—á–µ—Ä–∞', '–∞–ª–∫–æ–≥–æ–ª—è', '–≤—ã–ø–∏–ª', '–ø–∏–ª –∞–ª–∫–æ–≥–æ–ª—å', '—É–ø–æ—Ç—Ä–µ–±–ª—è–ª –∞–ª–∫–æ–≥–æ–ª—å'],
                'exercise': ['–Ω–∞–≥—Ä—É–∑–∫–∞', '—Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞', '—É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è', '—Ñ–∏–∑–∏—á–µ—Å–∫–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å', '–∑–∞–Ω–∏–º–∞–ª—Å—è —Å–ø–æ—Ä—Ç–æ–º', '–ø–æ—Å–ª–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏', '—Ñ–∏–∑–Ω–∞–≥—Ä—É–∑–∫–∞'],
                'stress': ['—Å—Ç—Ä–µ—Å—Å', '–Ω–µ—Ä–≤–Ω–∏—á–∞–ª', '–ø–µ—Ä–µ–∂–∏–≤–∞–ª', '—Å—Ç—Ä–µ—Å—Å–æ–≤–∞—è —Å–∏—Ç—É–∞—Ü–∏—è', '–ø–æ–¥ —Å—Ç—Ä–µ—Å—Å–æ–º', '–Ω–µ—Ä–≤—ã', '–ø–µ—Ä–µ–∂–∏–≤–∞–Ω–∏—è'],
                'fatigue': ['—É—Å—Ç–∞–ª–æ—Å—Ç—å', '—É—Å—Ç–∞–ª', '—É—Ç–æ–º–ª–µ–Ω–∏–µ', '—É—Å—Ç–∞–≤—à–∏–π', '—É—Ç–æ–º–∏–ª—Å—è', '–ø–µ—Ä–µ—É—Ç–æ–º–ª–µ–Ω–∏–µ', '–æ—á–µ–Ω—å —É—Å—Ç–∞–ª']
            };

            // Check each symptom independently (allows multiple symptoms)
            for (const [symptomKey, keywords] of Object.entries(symptomKeywords)) {
                for (const keyword of keywords) {
                    if (normalized.includes(keyword)) {
                        // Only add if not already in symptoms array
                        if (!symptoms.includes(symptomKey)) {
                            symptoms.push(symptomKey);
                        }
                        break; // Found this symptom, move to next
                    }
                }
            }

            // Validate readings
            if (systolic && diastolic && systolic > diastolic && 
                systolic >= 50 && systolic <= 300 && 
                diastolic >= 30 && diastolic <= 200) {
                
                console.log('Parsed voice symptoms:', symptoms);
                
                return {
                    systolic,
                    diastolic,
                    pulse: (pulse && pulse >= 30 && pulse <= 200) ? pulse : null,
                    symptoms
                };
            }

            return null;
        }

        function displayVoiceReadings(readings) {
            console.log('Voice readings symptoms:', readings.symptoms);
            
            const symptomsText = readings.symptoms && readings.symptoms.length > 0
                ? readings.symptoms.map(s => {
                    const label = symptomLabels[s];
                    console.log(`Voice mapping symptom '${s}' to '${label}'`);
                    return label || s; // Fallback to symptom key if label not found
                }).filter(Boolean).join(', ')
                : '–ù–µ —É–∫–∞–∑–∞–Ω—ã';
            
            const readingsText = `
–°–∏—Å—Ç–æ–ª–∏—á–µ—Å–∫–æ–µ: ${readings.systolic}
–î–∏–∞—Å—Ç–æ–ª–∏—á–µ—Å–∫–æ–µ: ${readings.diastolic}
${readings.pulse ? `–ü—É–ª—å—Å: ${readings.pulse}` : '–ü—É–ª—å—Å: –Ω–µ —É–∫–∞–∑–∞–Ω'}
–°–∏–º–ø—Ç–æ–º—ã: ${symptomsText}
            `;
            document.getElementById('voice-readings').textContent = readingsText.trim();
        }

        function useVoiceReadings() {
            if (!voiceReadings) {
                alert('–ù–µ—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã—Ö –ø–æ–∫–∞–∑–∞–Ω–∏–π');
                return;
            }

            // Fill form fields
            document.getElementById('systolic').value = voiceReadings.systolic;
            document.getElementById('diastolic').value = voiceReadings.diastolic;
            if (voiceReadings.pulse) {
                document.getElementById('pulse').value = voiceReadings.pulse;
            }

            // Clear and set symptoms
            clearSymptoms();
            if (voiceReadings.symptoms && voiceReadings.symptoms.length > 0) {
                voiceReadings.symptoms.forEach(symptom => {
                    const checkbox = document.getElementById(symptom);
                    if (checkbox) {
                        checkbox.checked = true;
                        checkbox.parentElement.classList.add('selected');
                    }
                });
            }

            // Hide voice result
            document.getElementById('voice-result').style.display = 'none';
            
            // Scroll to form
            document.getElementById('systolic').scrollIntoView({ behavior: 'smooth' });
            
            showToast('–ü–æ–∫–∞–∑–∞–Ω–∏—è –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω—ã –≤ —Ñ–æ—Ä–º—É', 'success');
        }

        async function saveVoiceReadings() {
            if (!voiceReadings) {
                alert('–ù–µ—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã—Ö –ø–æ–∫–∞–∑–∞–Ω–∏–π');
                return;
            }

            // Get current date and time
            const now = new Date();
            const date = now.toISOString().split('T')[0];
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const time = `${hours}:${minutes}`;

            // Create reading object
            const reading = {
                id: Date.now(),
                date,
                time,
                systolic: voiceReadings.systolic,
                diastolic: voiceReadings.diastolic,
                pulse: voiceReadings.pulse,
                notes: '–î–æ–±–∞–≤–ª–µ–Ω–æ —á–µ—Ä–µ–∑ –≥–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥',
                symptoms: voiceReadings.symptoms || [],
                timestamp: new Date(`${date}T${time}`)
            };

            try {
                // Check if database is available
                if (db) {
                    // Try to save to IndexedDB
                    await saveReading(reading);
                } else {
                    console.warn('Database not available, saving to memory only');
                }
                
                // Always add to in-memory array
                readings.push(reading);
                readings.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                // Update display
                updateDisplay();

                // Hide voice result
                document.getElementById('voice-result').style.display = 'none';
                
                // Clear voice readings
                voiceReadings = null;

                // Show success message
                showToast('–ò–∑–º–µ—Ä–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ —á–µ—Ä–µ–∑ –≥–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥!', 'success');
                
                // Update form date/time for next entry
                document.getElementById('date').value = date;
                document.getElementById('time').value = time;
                
                // Try to save to localStorage as backup
                try {
                    localStorage.setItem('bp_readings_backup', JSON.stringify(readings));
                } catch (e) {
                    console.warn('Could not save to localStorage:', e);
                }
                
            } catch (error) {
                console.error('Error saving voice reading:', error);
                
                // If IndexedDB fails, still try to save in memory
                if (!readings.some(r => r.id === reading.id)) {
                    readings.push(reading);
                    readings.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                    updateDisplay();
                    
                    // Show partial success
                    showToast('–ò–∑–º–µ—Ä–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤—Ä–µ–º–µ–Ω–Ω–æ (–ø—Ä–æ–±–ª–µ–º–∞ —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö)', 'info');
                    
                    // Update form
                    document.getElementById('voice-result').style.display = 'none';
                    voiceReadings = null;
                    document.getElementById('date').value = date;
                    document.getElementById('time').value = time;
                } else {
                    showToast('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏', 'error');
                }
            }
        }

        // Initialize speech recognition on page load
        window.addEventListener('load', () => {
            initSpeechRecognition();
        });
    </script>
</body>
</html>
